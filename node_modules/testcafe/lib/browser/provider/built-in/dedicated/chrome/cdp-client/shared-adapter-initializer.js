"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const execution_context_1 = __importDefault(require("./execution-context"));
const clients_manager_1 = require("./clients-manager");
const adapter_1 = require("../../../../../../shared/adapter");
adapter_1.initializeAdapter({
    PromiseCtor: Promise,
    nativeMethods: {
        setTimeout,
        clearTimeout,
        arrayIndexOf: Array.prototype.indexOf,
        arraySplice: Array.prototype.splice,
        arraySlice: Array.prototype.slice,
        arrayFilter: Array.prototype.filter,
        objectAssign: Object.assign,
        objectKeys: Object.keys,
        dateNow: Date.now,
    },
    isDomElement: () => false,
    scroll: async (el, opts) => {
        let currCxt = execution_context_1.default.current;
        let result = null;
        let margin = void 0;
        do {
            const { exceptionDetails, result: resultObj } = await clients_manager_1.getClient().Runtime.callFunctionOn({
                returnByValue: true,
                awaitPromise: true,
                executionContextId: execution_context_1.default.getCurrentContextId(),
                arguments: [{ objectId: el.objectId }, { value: opts }, { value: margin }],
                functionDeclaration: `function (el, opts) {
                    return window["%proxyless%"].scroll(el, opts);
                }`,
            });
            if (exceptionDetails)
                throw exceptionDetails;
            const scrollResult = resultObj.value;
            if (currCxt && currCxt !== currCxt.parent) {
                // TODO:
                //el           = findIframeByWindow(currCxt);
                currCxt = currCxt.parent;
                result = result !== null && result !== void 0 ? result : scrollResult.scrollWasPerformed;
                margin = scrollResult.maxScrollMargin;
                opts.offsetX = scrollResult.offsetX;
                opts.offsetY = scrollResult.offsetY;
            }
        } while (currCxt && currCxt !== currCxt.parent);
        return result;
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLWFkYXB0ZXItaW5pdGlhbGl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9zcmMvYnJvd3Nlci9wcm92aWRlci9idWlsdC1pbi9kZWRpY2F0ZWQvY2hyb21lL2NkcC1jbGllbnQvc2hhcmVkLWFkYXB0ZXItaW5pdGlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0RUFBbUQ7QUFHbkQsdURBQThDO0FBQzlDLDhEQUFxRTtBQUtyRSwyQkFBaUIsQ0FBQztJQUNkLFdBQVcsRUFBRSxPQUFPO0lBRXBCLGFBQWEsRUFBRTtRQUNYLFVBQVU7UUFDVixZQUFZO1FBQ1osWUFBWSxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTztRQUNyQyxXQUFXLEVBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNO1FBQ3BDLFVBQVUsRUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUs7UUFDbkMsV0FBVyxFQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTTtRQUNwQyxZQUFZLEVBQUUsTUFBTSxDQUFDLE1BQU07UUFDM0IsVUFBVSxFQUFJLE1BQU0sQ0FBQyxJQUFJO1FBQ3pCLE9BQU8sRUFBTyxJQUFJLENBQUMsR0FBRztLQUN6QjtJQUVELFlBQVksRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLO0lBRXpCLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBYyxFQUFFLElBQW1CLEVBQUUsRUFBRTtRQUNsRCxJQUFJLE9BQU8sR0FBRywyQkFBZ0IsQ0FBQyxPQUFrQyxDQUFDO1FBQ2xFLElBQUksTUFBTSxHQUFJLElBQXNCLENBQUM7UUFDckMsSUFBSSxNQUFNLEdBQUksS0FBSyxDQUFzQyxDQUFDO1FBRTFELEdBQUc7WUFDQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxHQUFHLE1BQU0sMkJBQVMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7Z0JBQ3JGLGFBQWEsRUFBUSxJQUFJO2dCQUN6QixZQUFZLEVBQVMsSUFBSTtnQkFDekIsa0JBQWtCLEVBQUcsMkJBQWdCLENBQUMsbUJBQW1CLEVBQUU7Z0JBQzNELFNBQVMsRUFBWSxDQUFDLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQztnQkFDcEYsbUJBQW1CLEVBQUU7O2tCQUVuQjthQUNMLENBQUMsQ0FBQztZQUVILElBQUksZ0JBQWdCO2dCQUNoQixNQUFNLGdCQUFnQixDQUFDO1lBRTNCLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxLQUE4QixDQUFDO1lBRTlELElBQUksT0FBTyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFO2dCQUN2QyxRQUFRO2dCQUNSLDZDQUE2QztnQkFDN0MsT0FBTyxHQUFRLE9BQU8sQ0FBQyxNQUFNLENBQUM7Z0JBQzlCLE1BQU0sR0FBUyxNQUFNLGFBQU4sTUFBTSxjQUFOLE1BQU0sR0FBSSxZQUFZLENBQUMsa0JBQWtCLENBQUM7Z0JBQ3pELE1BQU0sR0FBUyxZQUFZLENBQUMsZUFBZSxDQUFDO2dCQUM1QyxJQUFJLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7Z0JBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQzthQUN2QztTQUVKLFFBQ00sT0FBTyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFO1FBRTlDLE9BQU8sTUFBaUIsQ0FBQztJQUM3QixDQUFDO0NBQ0osQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV4ZWN1dGlvbkNvbnRleHQgZnJvbSAnLi9leGVjdXRpb24tY29udGV4dCc7XG5pbXBvcnQgeyBTZXJ2ZXJOb2RlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTY3JvbGxPcHRpb25zIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdGVzdC1ydW4vY29tbWFuZHMvb3B0aW9ucyc7XG5pbXBvcnQgeyBnZXRDbGllbnQgfSBmcm9tICcuL2NsaWVudHMtbWFuYWdlcic7XG5pbXBvcnQgeyBpbml0aWFsaXplQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3NoYXJlZC9hZGFwdGVyJztcbmltcG9ydCB7IExlZnRUb3BWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMvdmFsdWVzL2F4aXMtdmFsdWVzJztcbmltcG9ydCB7IFNjcm9sbFJlc3VsdFByb3h5bGVzcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL2NsaWVudC9jb3JlL3Njcm9sbCc7XG5cblxuaW5pdGlhbGl6ZUFkYXB0ZXIoe1xuICAgIFByb21pc2VDdG9yOiBQcm9taXNlLFxuXG4gICAgbmF0aXZlTWV0aG9kczoge1xuICAgICAgICBzZXRUaW1lb3V0LFxuICAgICAgICBjbGVhclRpbWVvdXQsXG4gICAgICAgIGFycmF5SW5kZXhPZjogQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXG4gICAgICAgIGFycmF5U3BsaWNlOiAgQXJyYXkucHJvdG90eXBlLnNwbGljZSxcbiAgICAgICAgYXJyYXlTbGljZTogICBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgIGFycmF5RmlsdGVyOiAgQXJyYXkucHJvdG90eXBlLmZpbHRlcixcbiAgICAgICAgb2JqZWN0QXNzaWduOiBPYmplY3QuYXNzaWduLFxuICAgICAgICBvYmplY3RLZXlzOiAgIE9iamVjdC5rZXlzLFxuICAgICAgICBkYXRlTm93OiAgICAgIERhdGUubm93LFxuICAgIH0sXG5cbiAgICBpc0RvbUVsZW1lbnQ6ICgpID0+IGZhbHNlLFxuXG4gICAgc2Nyb2xsOiBhc3luYyAoZWw6IFNlcnZlck5vZGUsIG9wdHM6IFNjcm9sbE9wdGlvbnMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJDeHQgPSBFeGVjdXRpb25Db250ZXh0LmN1cnJlbnQgYXMgRXhlY3V0aW9uQ29udGV4dCB8IG51bGw7XG4gICAgICAgIGxldCByZXN1bHQgID0gbnVsbCBhcyBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgbGV0IG1hcmdpbiAgPSB2b2lkIDAgYXMgdW5kZWZpbmVkIHwgTGVmdFRvcFZhbHVlczxudW1iZXI+O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhjZXB0aW9uRGV0YWlscywgcmVzdWx0OiByZXN1bHRPYmogfSA9IGF3YWl0IGdldENsaWVudCgpLlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24oe1xuICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6ICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlOiAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6ICBFeGVjdXRpb25Db250ZXh0LmdldEN1cnJlbnRDb250ZXh0SWQoKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6ICAgICAgICAgICBbeyBvYmplY3RJZDogZWwub2JqZWN0SWQgfSwgeyB2YWx1ZTogb3B0cyB9LCB7IHZhbHVlOiBtYXJnaW4gfV0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogYGZ1bmN0aW9uIChlbCwgb3B0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93W1wiJXByb3h5bGVzcyVcIl0uc2Nyb2xsKGVsLCBvcHRzKTtcbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uRGV0YWlscylcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb25EZXRhaWxzO1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxSZXN1bHQgPSByZXN1bHRPYmoudmFsdWUgYXMgU2Nyb2xsUmVzdWx0UHJveHlsZXNzO1xuXG4gICAgICAgICAgICBpZiAoY3VyckN4dCAmJiBjdXJyQ3h0ICE9PSBjdXJyQ3h0LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86XG4gICAgICAgICAgICAgICAgLy9lbCAgICAgICAgICAgPSBmaW5kSWZyYW1lQnlXaW5kb3coY3VyckN4dCk7XG4gICAgICAgICAgICAgICAgY3VyckN4dCAgICAgID0gY3VyckN4dC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICAgICAgID0gcmVzdWx0ID8/IHNjcm9sbFJlc3VsdC5zY3JvbGxXYXNQZXJmb3JtZWQ7XG4gICAgICAgICAgICAgICAgbWFyZ2luICAgICAgID0gc2Nyb2xsUmVzdWx0Lm1heFNjcm9sbE1hcmdpbjtcbiAgICAgICAgICAgICAgICBvcHRzLm9mZnNldFggPSBzY3JvbGxSZXN1bHQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBvcHRzLm9mZnNldFkgPSBzY3JvbGxSZXN1bHQub2Zmc2V0WTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjdXJyQ3h0ICYmIGN1cnJDeHQgIT09IGN1cnJDeHQucGFyZW50KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0IGFzIGJvb2xlYW47XG4gICAgfSxcbn0pO1xuIl19